{"version":3,"file":"auth-B3oSFb2k.js","sources":["../../core/auth.js"],"sourcesContent":["// OAuth configuration for storage providers\r\n// Note: In production, you should create your own OAuth apps for each provider\r\n\r\nexport const OAUTH_CONFIG = {\r\n  dropbox: {\r\n    clientId: 'lgtet4ml5qp0qo8',\r\n    redirectUri: window.location.origin + '/auth-callback.html',\r\n    authEndpoint: 'https://www.dropbox.com/oauth2/authorize',\r\n    scopes: 'files.content.write files.content.read'\r\n  },\r\n  \r\n  onedrive: {\r\n    clientId: '460ec8b8-1a36-4565-bd95-6d88726e7b65',\r\n    redirectUri: window.location.origin + '/auth-callback.html',\r\n    authority: 'https://login.microsoftonline.com/common',\r\n    scopes: ['Files.ReadWrite', 'User.Read']\r\n  },\r\n  \r\n  googledrive: {\r\n    clientId: '813636040653-ub690hjmd47hknlb9g6pu5bet9d5mv0v.apps.googleusercontent.com',\r\n    redirectUri: window.location.origin,\r\n    authEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\r\n    scopes: 'https://www.googleapis.com/auth/drive.file',\r\n    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']\r\n  }\r\n};\r\n\r\n// Storage keys\r\nexport const PROVIDER_KEY = 'noteel_selected_provider_v1';\r\nexport const TOKENS_KEY = 'noteel_oauth_tokens_v1';\r\n\r\n// Get selected storage provider\r\nexport function getSelectedProvider() {\r\n  return localStorage.getItem(PROVIDER_KEY) || null;\r\n}\r\n\r\n// Set selected storage provider\r\nexport function setSelectedProvider(provider) {\r\n  localStorage.setItem(PROVIDER_KEY, provider);\r\n}\r\n\r\n// Get OAuth tokens for a provider\r\nexport function getTokens(provider) {\r\n  const tokens = localStorage.getItem(TOKENS_KEY);\r\n  if (!tokens) return null;\r\n  try {\r\n    const parsed = JSON.parse(tokens);\r\n    return parsed[provider] || null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Save OAuth tokens for a provider\r\nexport function saveTokens(provider, tokens) {\r\n  let allTokens = {};\r\n  const existing = localStorage.getItem(TOKENS_KEY);\r\n  if (existing) {\r\n    try {\r\n      allTokens = JSON.parse(existing);\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n  allTokens[provider] = tokens;\r\n  localStorage.setItem(TOKENS_KEY, JSON.stringify(allTokens));\r\n}\r\n\r\n// Clear OAuth tokens for a provider\r\nexport function clearTokens(provider) {\r\n  const existing = localStorage.getItem(TOKENS_KEY);\r\n  if (!existing) return;\r\n  try {\r\n    const allTokens = JSON.parse(existing);\r\n    delete allTokens[provider];\r\n    localStorage.setItem(TOKENS_KEY, JSON.stringify(allTokens));\r\n  } catch {\r\n    // ignore\r\n  }\r\n}\r\n\r\n// Generate random state for OAuth\r\nexport function generateState() {\r\n  const array = new Uint8Array(16);\r\n  crypto.getRandomValues(array);\r\n  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\n// Generate PKCE code verifier\r\nexport function generateCodeVerifier() {\r\n  const array = new Uint8Array(32);\r\n  crypto.getRandomValues(array);\r\n  return base64URLEncode(array);\r\n}\r\n\r\n// Generate PKCE code challenge from verifier\r\nexport async function generateCodeChallenge(verifier) {\r\n  const encoder = new TextEncoder();\r\n  const data = encoder.encode(verifier);\r\n  const hash = await crypto.subtle.digest('SHA-256', data);\r\n  return base64URLEncode(new Uint8Array(hash));\r\n}\r\n\r\n// Base64 URL encoding helper\r\nfunction base64URLEncode(buffer) {\r\n  const base64 = btoa(String.fromCharCode(...buffer));\r\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n}\r\n\r\n// Parse OAuth callback hash/query parameters\r\nexport function parseOAuthCallback() {\r\n  const hash = window.location.hash.substring(1);\r\n  const query = window.location.search.substring(1);\r\n  const params = new URLSearchParams(hash || query);\r\n  return {\r\n    accessToken: params.get('access_token'),\r\n    code: params.get('code'),\r\n    state: params.get('state'),\r\n    error: params.get('error'),\r\n    errorDescription: params.get('error_description')\r\n  };\r\n}\r\n"],"names":["OAUTH_CONFIG","PROVIDER_KEY","TOKENS_KEY","getSelectedProvider","setSelectedProvider","provider","getTokens","tokens","saveTokens","allTokens","existing","generateState","array","byte","generateCodeVerifier","base64URLEncode","generateCodeChallenge","verifier","data","hash","buffer","parseOAuthCallback","query","params"],"mappings":"ssBAGY,MAACA,EAAe,CAC1B,QAAS,CACP,SAAU,kBACV,YAAa,OAAO,SAAS,OAAS,sBACtC,aAAc,0CAEhB,EAEA,SAAU,CACR,SAAU,uCACV,YAAa,OAAO,SAAS,OAAS,sBACtC,UAAW,2CACX,OAAQ,CAAC,kBAAmB,WAAW,CAC3C,EAEE,YAAa,CACX,SAAU,2EACV,YAAa,OAAO,SAAS,OAC7B,aAAc,+CACd,OAAQ,4CAEV,CACF,EAGaC,EAAe,8BACfC,EAAa,yBAGnB,SAASC,GAAsB,CACpC,OAAO,aAAa,QAAQF,CAAY,GAAK,IAC/C,CAGO,SAASG,EAAoBC,EAAU,CAC5C,aAAa,QAAQJ,EAAcI,CAAQ,CAC7C,CAGO,SAASC,EAAUD,EAAU,CAClC,MAAME,EAAS,aAAa,QAAQL,CAAU,EAC9C,GAAI,CAACK,EAAQ,OAAO,KACpB,GAAI,CAEF,OADe,KAAK,MAAMA,CAAM,EAClBF,CAAQ,GAAK,IAC7B,MAAQ,CACN,OAAO,IACT,CACF,CAGO,SAASG,EAAWH,EAAUE,EAAQ,CAC3C,IAAIE,EAAY,CAAA,EAChB,MAAMC,EAAW,aAAa,QAAQR,CAAU,EAChD,GAAIQ,EACF,GAAI,CACFD,EAAY,KAAK,MAAMC,CAAQ,CACjC,MAAQ,CAER,CAEFD,EAAUJ,CAAQ,EAAIE,EACtB,aAAa,QAAQL,EAAY,KAAK,UAAUO,CAAS,CAAC,CAC5D,CAgBO,SAASE,GAAgB,CAC9B,MAAMC,EAAQ,IAAI,WAAW,EAAE,EAC/B,cAAO,gBAAgBA,CAAK,EACrB,MAAM,KAAKA,EAAOC,GAAQA,EAAK,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,EAAE,KAAK,EAAE,CAC9E,CAGO,SAASC,GAAuB,CACrC,MAAMF,EAAQ,IAAI,WAAW,EAAE,EAC/B,cAAO,gBAAgBA,CAAK,EACrBG,EAAgBH,CAAK,CAC9B,CAGO,eAAeI,EAAsBC,EAAU,CAEpD,MAAMC,EADU,IAAI,cACC,OAAOD,CAAQ,EAC9BE,EAAO,MAAM,OAAO,OAAO,OAAO,UAAWD,CAAI,EACvD,OAAOH,EAAgB,IAAI,WAAWI,CAAI,CAAC,CAC7C,CAGA,SAASJ,EAAgBK,EAAQ,CAE/B,OADe,KAAK,OAAO,aAAa,GAAGA,CAAM,CAAC,EACpC,QAAQ,MAAO,GAAG,EAAE,QAAQ,MAAO,GAAG,EAAE,QAAQ,KAAM,EAAE,CACxE,CAGO,SAASC,GAAqB,CACnC,MAAMF,EAAO,OAAO,SAAS,KAAK,UAAU,CAAC,EACvCG,EAAQ,OAAO,SAAS,OAAO,UAAU,CAAC,EAC1CC,EAAS,IAAI,gBAAgBJ,GAAQG,CAAK,EAChD,MAAO,CACL,YAAaC,EAAO,IAAI,cAAc,EACtC,KAAMA,EAAO,IAAI,MAAM,EACvB,MAAOA,EAAO,IAAI,OAAO,EACzB,MAAOA,EAAO,IAAI,OAAO,EACzB,iBAAkBA,EAAO,IAAI,mBAAmB,CACpD,CACA"}